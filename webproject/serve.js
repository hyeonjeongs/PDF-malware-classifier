//const shell =require('shelljs')
const express = require('express');
const app = express();
const bodyParser = require('body-parser');
const fs = require('fs')
const multer = require('multer');
app.use(bodyParser.urlencoded({extended:false}));
app.use(bodyParser.json());
app.use(express.static('public'));
const path = require('path');
const { response, query } = require('express');
const storage = multer.diskStorage({
  //destination 업로드된 파일의 경로를 설정하는 데 사용되며 콜백 함수 또는 문자열을 받을 수 있습니다.
  //콜백 함수를 전달하는 경우 경로가 유효한지 확인해야 합니다.
  destination: 'uploads/',

  //filename 속성은 업로드 후 서버에 저장되는 파일의 이름을 지정하는 데 사용
  filename: function (req, file, cb) {
    //cb(null, file.fieldname + '-' + Date.now())
    
    //파일 확장자 가져오기
    let fname = file.originalname;
    let extName = '';
    
    //파일에 확장자가 있는지 확인
    if(fname.lastIndexOf('.') != -1){
      extName = fname.slice(fname.lastIndexOf('.'));
    }

    //파일을 업로드할 때 일반적으로 사용자의 파일 이름이 서버에 직접 저장되지 않습니다
    //파일 이름은 무작위로 생성
    cb(null, file.fieldname + '-' + Date.now()+extName);
  }
})
const upload = multer(
  {
    storage: storage,
    limits:{
     }
  });
app.post('/testUpload' , (req , res)=>{
  //요청 본문을 구문 분석하는 함수 가져오기
  let fu = upload.array('file'); //여러 파일을 저장할 수 있도록 배열로 받음

  //수동으로 함수를 호출하여 요청 본문을 구문 분석
  fu(req , res , (err)=>{
    if(err){
      console.log(err)
      //파일 크기가 표준 넘으면 업로드 불가능
      res.send('파일이 너무 크니 100MB 이하의 파일을 올려주세요！！');
    }else{
      /*
      //parsing
      //get file form web server
      shell.exec('ls -d ~/projectnew/uploads/* > ~/hidost/build/uploadpdf.txt');

      //caching
      shell.exec('~/hidost/build/src/cacher -i ~/hidost/build/uploadpdf.txt --compact --values -c ~/hidost/build/uploadcache/ -t10 -m256');

      //cached-pdf.txt
      shell.exec('find ~/hidost/build/uploadcache -name "*.pdf" -not -empty >~/hidost/build/cached-mpdfs.txt');

      //data.libsvm
      shell.exec('~/hidost/build/src/feat-extract -b ~/hidost/build/test.txt -m ~/hidost/build/cached-mpdfs.txt -f ~/hidost/build/features.nppf --values -o ~/hidost/build/data.libsvm');

      //libsvm --> csv
      shell.exec('python ~/hidost/build/libsvm_to_csv.py > ~/hidost/build/test.csv');

      //ML prediction
      shell.exec('python3 ~/hidost/build/prediction.py > ~/hidost/build/result.txt');

      //mv file
      shell.exec('mv ~/projectnew/uploads/* ~/dataset/malicious');

      //remove files for new pdf parsing without output.csv
      //remove files in build
      shell.exec('rm ~/hidost/build/data.libsvm ~/hidost/build/uploadpdf.txt');
      shell.exec('rm -r ~/hidost/build/uploadcache');
      shell.exec('mkdir ~/hidost/build/uploadcache');
      */

      let username = req.body.username;
      const file = path.resolve(__dirname, 'text.txt')
      fs.readFile(file, function (err, data) {
      console.log("읽기: " + data.toString());
      res.send(data.toString())
      });
    }
  });
});
app.get('/testRead',(req,res)=>{
  
  //교차 도메인을 허용하는 도메인 이름 설정, *는 모든 도메인 이름이 도메인 간 허용됨을 의미
  res.setHeader('Access-Control-Allow-Origin','*');
  //도메인 전체에 허용되는 헤더 유형
  res.setHeader('Access-Control-Allow-Headers','Content-type,Content-Length,Authorization,Accept,X-Requested-Width');
  //도메인 간 허용 요청 방법
  res.setHeader('Access-Control-Allow-Methods','PUT,POST,GET,DELETE,OPTIONS');
  const file = path.resolve(__dirname,'text.txt')
  fs.readFile(file, function (err, data) {
    if (err) {
        return console.error(err);
    }
    console.log('읽기: ' + data.toString());
    res.send(data.toString())
 });

})


app.listen(3333,()=>{
  console.log('success');
});